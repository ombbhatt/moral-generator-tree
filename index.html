<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CSV Tree Visualizer</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }
    #root {
      height: 100vh;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const Upload = ({ size = 24 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"/>
      </svg>
    );

    const CSVTreeVisualizer = () => {
      const [files, setFiles] = useState([]);
      const [allTrees, setAllTrees] = useState([]);
      const [currentScenario, setCurrentScenario] = useState(0);
      const [selectedNode, setSelectedNode] = useState(null);
      const [manipulationOrder, setManipulationOrder] = useState([]);
      const svgRef = useRef(null);

      const handleFileUpload = async (e) => {
        const uploadedFiles = Array.from(e.target.files);
        setFiles(uploadedFiles);

        // Parse the single CSV file
        const file = uploadedFiles[0];
        const text = await file.text();
        const result = Papa.parse(text, { header: true, skipEmptyLines: true });
        const allData = result.data;

        const order = detectManipulationOrder(allData);
        setManipulationOrder(order);
        console.log('Detected manipulation order:', order);

        const trees = buildMultipleTrees(allData);
        setAllTrees(trees);
        setCurrentScenario(0);
      };

      const detectManipulationOrder = (data) => {
        // Find the first non-base variant to determine the order
        const sortedData = data
          .filter(d => d.variants && d.text)
          .sort((a, b) => {
            const aDepth = a.variants.split(',').length;
            const bDepth = b.variants.split(',').length;
            return aDepth - bDepth;
          });

        const order = [];
        const elements = ['causality', 'intentionality', 'utility', 'permissibility'];

        // Track which elements appear at each level
        for (const row of sortedData) {
          const parts = row.variants.split(',').map(p => p.trim());
          if (parts.length === 1) continue; // Skip base

          const lastVariant = parts[parts.length - 1];
          
          // Find which element this variant belongs to
          for (const element of elements) {
            if (lastVariant.includes(element) && !order.includes(element)) {
              order.push(element);
              break;
            }
          }

          if (order.length === 4) break;
        }

        return order;
      };

      const getElementColor = (element) => {
        const colors = {
          'causality': '#f59e0b',      // amber
          'intentionality': '#10b981',  // green
          'utility': '#8b5cf6',         // purple
          'permissibility': '#ec4899'   // pink
        };
        return colors[element] || '#6b7280';
      };

      const getLevelElement = (depth) => {
        if (depth === 0) return 'base';
        if (depth - 1 < manipulationOrder.length) {
          return manipulationOrder[depth - 1];
        }
        return 'unknown';
      };

      const getShorthandId = (variantsPath) => {
        const parts = variantsPath.split(',').map(p => p.trim());
        if (parts.length === 1 && parts[0] === 'base') return 'b-';
        
        let id = 'b-';
        for (let i = 1; i < parts.length; i++) {
          const variant = parts[i];
          const element = manipulationOrder[i - 1];
          if (!element) continue;
          
          const initial = element[0]; // First letter: c, i, u, or p
          const value = variant.includes('high-') ? '1' : '0';
          id += `${initial}${value}`;
        }
        return id;
      };

      const buildMultipleTrees = (data) => {
        // Count base rows to determine number of scenarios
        const baseRows = data.filter(d => {
          if (!d.variants) return false;
          return d.variants.trim() === 'base';
        });

        const numScenarios = baseRows.length;
        console.log(`Detected ${numScenarios} scenarios (from ${baseRows.length} base rows)`);

        // Split data into scenarios
        const scenarios = [];
        for (let i = 0; i < numScenarios; i++) {
          scenarios.push([]);
        }

        // Group rows by scenario based on their order
        const sortedData = data
          .filter(d => d.variants && d.text)
          .sort((a, b) => {
            const aDepth = a.variants.split(',').length;
            const bDepth = b.variants.split(',').length;
            return aDepth - bDepth;
          });

        // Distribute rows to scenarios
        const variantCounts = {};
        sortedData.forEach(row => {
          const variants = row.variants.trim();
          if (!variantCounts[variants]) {
            variantCounts[variants] = 0;
          }
          const scenarioIndex = variantCounts[variants];
          if (scenarioIndex < numScenarios) {
            scenarios[scenarioIndex].push(row);
          }
          variantCounts[variants]++;
        });

        // Build a tree for each scenario
        return scenarios.map((scenarioData, idx) => buildTree(scenarioData, idx));
      };

      const buildTree = (data, scenarioIndex) => {
        const root = {
          name: 'base',
          variants: 'base',
          text: '',
          option1: '',
          option2: '',
          children: [],
          scenarioIndex
        };

        const baseEntry = data.find(d => d.variants === 'base');
        if (baseEntry) {
          root.text = baseEntry.text;
          root.option1 = baseEntry['options\\.1'] || baseEntry['options.1'] || baseEntry['options/.1'] || '';
          root.option2 = baseEntry['options\\.2'] || baseEntry['options.2'] || baseEntry['options/.2'] || '';
        }

        const nodeMap = { 'base': root };

        const sortedData = data
          .filter(d => d.variants && d.text)
          .sort((a, b) => {
            const aDepth = a.variants.split(',').length;
            const bDepth = b.variants.split(',').length;
            return aDepth - bDepth;
          });

        sortedData.forEach(row => {
          const variants = row.variants.trim();
          if (variants === 'base' || nodeMap[variants]) return;

          const parts = variants.split(',').map(p => p.trim());
          const parentVariants = parts.slice(0, -1).join(',');
          const currentVariant = parts[parts.length - 1];

          if (nodeMap[parentVariants]) {
            const newNode = {
              name: currentVariant,
              variants: variants,
              text: row.text || '',
              option1: row['options\\.1'] || row['options.1'] || row['options/.1'] || '',
              option2: row['options\\.2'] || row['options.2'] || row['options/.2'] || '',
              children: [],
              scenarioIndex
            };
            nodeMap[parentVariants].children.push(newNode);
            nodeMap[variants] = newNode;
          }
        });

        return root;
      };

      useEffect(() => {
        if (allTrees.length > 0 && svgRef.current) {
          drawTree();
        }
      }, [allTrees, currentScenario, manipulationOrder]);

      const drawTree = () => {
        if (allTrees.length === 0) return;

        const svg = d3.select(svgRef.current);
        svg.selectAll("*").remove();

        const width = svgRef.current.clientWidth;
        const height = svgRef.current.clientHeight;

        const g = svg.append("g");

        const treeData = allTrees[currentScenario];
        const hierarchy = d3.hierarchy(treeData);
        
        const treeLayout = d3.tree().size([height * 2, width - 200])
          .separation((a, b) => (a.parent == b.parent ? 1 : 1.2));
        const treeNodes = treeLayout(hierarchy);

        const zoom = d3.zoom()
          .scaleExtent([0.1, 3])
          .on('zoom', (event) => {
            g.attr('transform', event.transform);
          });
        
        svg.call(zoom);
        g.attr('transform', `translate(100,100)`);

        const link = g.selectAll('.link')
          .data(treeNodes.links())
          .enter()
          .append('path')
          .attr('class', 'link')
          .attr('fill', 'none')
          .attr('stroke', '#94a3b8')
          .attr('stroke-width', 2)
          .attr('d', d3.linkHorizontal()
            .x(d => d.y)
            .y(d => d.x)
          );

        const node = g.selectAll('.node')
          .data(treeNodes.descendants())
          .enter()
          .append('g')
          .attr('class', 'node')
          .attr('transform', d => `translate(${d.y},${d.x})`)
          .style('cursor', 'pointer')
          .on('click', (event, d) => {
            setSelectedNode(d.data);
          });

        node.append('circle')
          .attr('r', 8)
          .attr('fill', d => {
            const depth = d.depth;
            if (depth === 0) return '#3b82f6'; // Base - blue
            const element = getLevelElement(depth);
            return getElementColor(element);
          })
          .attr('stroke', '#fff')
          .attr('stroke-width', 2);

        node.append('text')
          .attr('dy', -15)
          .attr('text-anchor', 'middle')
          .attr('font-size', '12px')
          .attr('fill', '#1e293b')
          .attr('font-weight', '500')
          .text(d => d.data.name);

        // Add shorthand ID below the node
        node.append('text')
          .attr('dy', 20)
          .attr('text-anchor', 'middle')
          .attr('font-size', '10px')
          .attr('fill', '#64748b')
          .attr('font-weight', '600')
          .text(d => getShorthandId(d.data.variants));
      };

      return (
        <div className="w-full h-screen bg-gray-50 flex flex-col">
          <div className="bg-white border-b border-gray-200 p-4">
            <h1 className="text-2xl font-bold text-gray-900 mb-4">CSV Tree Visualizer</h1>
            
            <div className="flex gap-4 items-center flex-wrap">
              <label className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg cursor-pointer hover:bg-blue-700 transition-colors">
                <Upload size={20} />
                <span>Upload CSV File</span>
                <input
                  type="file"
                  accept=".csv"
                  onChange={handleFileUpload}
                  className="hidden"
                />
              </label>

              {files.length > 0 && (
                <span className="text-sm text-gray-600">
                  {files[0].name} loaded
                </span>
              )}

              {allTrees.length > 0 && (
                <div className="flex gap-2 items-center">
                  <span className="text-sm font-semibold text-gray-700">Scenario:</span>
                  {allTrees.map((_, idx) => (
                    <button
                      key={idx}
                      onClick={() => setCurrentScenario(idx)}
                      className={`px-3 py-1 rounded ${currentScenario === idx ? 'bg-purple-600 text-white' : 'bg-gray-200 text-gray-700'}`}
                    >
                      {idx + 1}
                    </button>
                  ))}
                </div>
              )}
            </div>

            {manipulationOrder.length > 0 && (
              <div className="mt-3 text-sm text-gray-600">
                <span className="font-semibold">Detected order:</span> {manipulationOrder.join(' → ')}
              </div>
            )}
          </div>

          <div className="flex-1 flex overflow-hidden">
            <div className="flex-1 relative">
              {allTrees.length === 0 ? (
                <div className="absolute inset-0 flex items-center justify-center text-gray-400">
                  <div className="text-center">
                    <Upload size={48} />
                    <p className="mt-2">Upload CSV file to visualize the tree structure</p>
                    <p className="mt-1 text-sm">The tool will automatically detect scenarios and manipulation order</p>
                  </div>
                </div>
              ) : (
                <svg ref={svgRef} className="w-full h-full" />
              )}
            </div>

            {selectedNode && (
              <div className="w-96 bg-white border-l border-gray-200 p-4 overflow-y-auto">
                <div className="flex justify-between items-start mb-4">
                  <h2 className="text-lg font-bold text-gray-900">Node Details</h2>
                  <button
                    onClick={() => setSelectedNode(null)}
                    className="text-gray-400 hover:text-gray-600 text-2xl leading-none"
                  >
                    ×
                  </button>
                </div>

                <div className="space-y-4">
                  <div>
                    <label className="text-sm font-semibold text-gray-700">Scenario</label>
                    <p className="text-sm text-gray-900 mt-1">Scenario {selectedNode.scenarioIndex + 1}</p>
                  </div>

                  <div>
                    <label className="text-sm font-semibold text-gray-700">Variant</label>
                    <p className="text-sm text-gray-900 mt-1">{selectedNode.name}</p>
                  </div>

                  <div>
                    <label className="text-sm font-semibold text-gray-700">Full Path</label>
                    <p className="text-sm text-gray-900 mt-1 font-mono bg-gray-50 p-2 rounded">
                      {selectedNode.variants}
                    </p>
                  </div>

                  <div>
                    <label className="text-sm font-semibold text-gray-700">Text Content</label>
                    <p className="text-sm text-gray-900 mt-1 whitespace-pre-wrap bg-gray-50 p-3 rounded">
                      {selectedNode.text || 'No text available'}
                    </p>
                  </div>

                  {selectedNode.option1 && (
                    <div>
                      <label className="text-sm font-semibold text-gray-700">Option 1</label>
                      <p className="text-sm text-gray-900 mt-1 whitespace-pre-wrap bg-gray-50 p-3 rounded">
                        {selectedNode.option1}
                      </p>
                    </div>
                  )}

                  {selectedNode.option2 && (
                    <div>
                      <label className="text-sm font-semibold text-gray-700">Option 2</label>
                      <p className="text-sm text-gray-900 mt-1 whitespace-pre-wrap bg-gray-50 p-3 rounded">
                        {selectedNode.option2}
                      </p>
                    </div>
                  )}

                  {selectedNode.children && selectedNode.children.length > 0 && (
                    <div>
                      <label className="text-sm font-semibold text-gray-700">Children</label>
                      <ul className="text-sm text-gray-900 mt-1 space-y-1">
                        {selectedNode.children.map((child, i) => (
                          <li key={i} className="bg-gray-50 p-2 rounded">
                            {child.name}
                          </li>
                        ))}
                      </ul>
                    </div>
                  )}
                </div>
              </div>
            )}
          </div>

          <div className="bg-white border-t border-gray-200 px-4 py-2 text-xs text-gray-600">
            <div className="flex gap-4 flex-wrap">
              <span className="flex items-center gap-1">
                <span className="w-3 h-3 rounded-full bg-blue-600"></span> Base
              </span>
              {manipulationOrder.map((element, idx) => (
                <span key={idx} className="flex items-center gap-1">
                  <span className="w-3 h-3 rounded-full" style={{backgroundColor: getElementColor(element)}}></span>
                  {element.charAt(0).toUpperCase() + element.slice(1)} (Level {idx + 1})
                </span>
              ))}
              {allTrees.length > 0 && (
                <span className="ml-auto">
                  Viewing Scenario {currentScenario + 1} of {allTrees.length}
                </span>
              )}
            </div>
          </div>
        </div>
      );
    };

    ReactDOM.render(<CSVTreeVisualizer />, document.getElementById('root'));
  </script>
</body>
</html>